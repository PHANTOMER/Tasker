1. Для установки службы необходимо после построения решения запустить installer из проекта Tasker.Setup (setup.exe). Во время установки
необходимо будет ввести учетные данные и электронный адрес почтового ящика, с которого будут отправляться письма для соответствующего типа задач.
Также необходимо ввести учетные данные пользователя, от которого будет запущена служба.

2. Для введения нового типа задач необходимо создать класс, имплементирующий интерфейс ITaskExecutor, добавить новый элемент в enum TaskType. Реализовать
необходимую логику.

3. Для запуска приложения в режиме отладки необходимо в файле app.config присвоить флагу IsConsole значение "True".

P.S. поскольку в ТЗ не было указано, каким образом задачи будут распределяться между экземплярами приложения, мной был выбран следующий порядок:
1) В файле конфигурации находится ключ "MaxConcurrentTasks", определяющий количество задач, которые могут обрабатываться одним экземпляром (5 по-умолчанию);
2) При первом запуске службы создается уникальный идентификатор экземпляра приложения. Он необходим для того, чтобы идентифицировать, какому экземпляру принадлежит 
задача в базе;
3) При первом запуске приложения происходит чтение из базы задач в состоянии "Created";
4) После чтения задачам присваивается идентификатор экземпляра. Таким образом каждая задача будет выполнена лишь единожды;
5) При добавлении новой задачи в базу SQL Server отсылает уведомление, которое обрабатывается при помощи SqlDependency. Таким образом экземпляры получают информацию
о новых добавленных задачах, и первый экземпляр, у которого не превышен лимит выполняемых задач, возьмет эту задачу на выполнение;
6) После окончания выполнения очередной задачи, происходит обращение к базе с целью проверки на наличие новых задач;
7) Если работа службы аварийно завершается, то, при помощи идентификатора экземпляра, при следующем запуске задачи будут заново обработаны этим экземпляром.
Все это было сделано с целью обеспечения единственного выполнения каждой задачи. Другим вариантом решения могла быть замена идентификатора экземпляра обычным
булевым полем, определяющим, что данная задача уже была взята на выполнение, но в таком случае, 
после аварийного завершения, это поле не сбрасывалось бы и задачи никогда бы не были завершены. Самым хорошим решением является использование очереди задач
(RabbitMQ, Azure Web Queues или другой), но я посчитал, что в данном случае эти трудозатраты будут лишними.